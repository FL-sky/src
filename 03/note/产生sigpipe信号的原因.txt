https://blog.csdn.net/u010821666/article/details/81841755

产生SIGPIPE的原因
SIGPIPE信号产生的原因：
简单来说，就是客户端程序向服务器端程序发送了消息，然后关闭客户端，服务器端返回消息的时候就会收到内核给的SIGPIPE信号。
TCP的全双工信道其实是两条单工信道，client端调用close的时候，虽然本意是关闭两条信道，但是其实只能关闭它发送的那一条单工信道，还是可以接受数据，server端还是可以发送数据，并不知道client端已经完全关闭了。
————————————————

以下为引用：
”’对一个已经收到FIN包的socket调用read方法, 如果接收缓冲已空, 则返回0, 这就是常说的表示连接关闭. 但第一次对其调用write方法时, 如果发送缓冲没问题, 会返回正确写入(发送). 但发送的报文会导致对端发送RST报文, 因为对端的socket已经调用了close, 完全关闭, 既不发送, 也不接收数据. 所以, 第二次调用write方法(假设在收到RST之后), 会生成SIGPIPE信号, 导致进程退出.”’
